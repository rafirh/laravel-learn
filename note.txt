Yang sudah diimplementasikan:
    1. Routing:
        - dir: Routes/web.php
        - write: Route::get('(endpoint)', [(class controller)::class, 'function name']);
        - example: Route::get('/', [HomeController::class, 'index']);
    2. Models
        - dir: App/Models
    3. Controller
        - dir: App/http/Controller
    4. Partials / Component
        - dir: resourses/views/partials
        - example: navbar, footer, card.
    5. Database Migration:
        - migrate
        - migrate:rollback
        - migrate:fresh
    6. Tinker
        - how to acces: php artisan tinker
        - $user = new App\Models\User (acces class user Models)
        - $user = new User (create new object)
        - $user -> save() (save object to database)
        - $user -> all() (get all data from user table)
    7. Valet
        - Deploy a webite with local host (example.test)
    8. API
        - REST adalah REpresentational State Transfer atau gaya arsitektur untuk menyediakan standar antara sistem komputer di web, sehingga memudahkan sistem untuk saling berinteraksi.
        - Contoh kaidah rest api adalah penggunaan endpoint yang sama dalam satu model, hanya dibedakan dari method nya saja.
        - RESTful api adalah sebuah api yang sudah mengimplementasikan prinsip-prinsip rest api.

Method-method dalam model laravel:
    misal = - class model: Post
    1. Post::all(); //mendapatkan semua data dari model Post.
    2. $post = new Post; //membuat object baru.
    3. Post->save(); //menyimpan object post ke database.
    4. Post::create([
        "title" => "this is title",
        "excerpt" => "wkwk",
        "body" => "hahaha"
    ]) // berfungsi untuk menambahkan data ke model post.
    5. Post::where('title', 'wkwk') -> update (['title', 'judul baru']); //mengubah title dari 'wkwk' ke 'judul baru' dimana title == wkwk.
    6. Post::first(); //mengambil data pertama pada model post.
    7. Post::find(1); //mengambil data yang ber id kan 1

Episode 8: (Post Category dan Eloquent)
    1. protected $guarded = ['id']; // berfungsi agar field id dijaga agar tidak diisi dengan mass assignment
    2. $table->foreignId('category_id'); // berfungsi menambahkan field foreign key yang nantinya digunakan untuk relasi table
    3. Category::function() // berfungsi untuk memanggil method yang ada di class category seperti all(), first(), create(), dll
    4. One to many // menggunakan method hasMany(), contoh one to many adalah tabel category berelasi ke tabel post
    5. Many to one // menggunakan method belongsTo()
    6.  public function category(){ // fungsi ini berada di model post
            return $this->belongsTo(Category::class); // sebuah post meiliki satu kategori
        }
        fungsi ini digunakan untuk merelasikan model post dengan model category yang ditulis di class model post.
    7. public function post(){ // fungsi ini berada di model category
        return $this->hasMany(Post::class); // satu kategori memiliki banyak post.
    }
    8. Post::first()->category->name; // mengambil data berupa nama category berdasarkan category_id di postingan pertama.
    9. hasMany() berkebalikan dengan belongsTo(), category hasMany() posts dan post belongsTo category.

Episode 9: (Database Seeder)
    1. $table->foreignId('user_id'); // digunakan untuk perantara untuk merelasikan tabel posts dengan tabel user berdasarkan user_id.
    2. seeder digunakan untuk mengisi, menghapus, dan update (DML) data pada tabel tertentu.
    3. migration digunakan untuk membuat database dan tabel didalammya (DDL).
    4. php artisan db:seed // digunakan untuk menjalankan perintah yang ada di DatabaseSeeder.php.
    5. php artisan db:seed // hanya bisa dilakukan sekali jika terdapat data yang di set unique
    6. php artisan migrate:fresh --seed // perintah ini digunakan untuk migration database dan juga db seeding.
    7. $post->user->name // digunakan untuk mengambil data user berupa name dari model post yang berelasikan dengan model user.

Episode 10: (Factory dan Faker)
    1. Faker sebuah tools yang digunakan untuk membuat data palsu berbasis php.
    2. Factory adalah pabrik pembuat data otomatis, untuk membuat data ini, kita dibantu oleh faker agar data terlihat asli.
    3. php artisan make:factory <name-factory> // digunakan untuk membuat factory
    4. Method-method yang ada di factory akan dipanggil di file database seeder.
    5. 'title' => $this->faker->sentence(mt_rand(2, 7)) // digunakan untuk mengisi data kolom title dengan method yang ada di faker yaitu sentence()
    6. 'faker_locale' => env('FAKER_LOCALE', 'en_US'), // digunakan untuk mengkonfigurasi bahasa yang digunakan untuk membuat data dengan faker, kita dapat menyimpannya di env variable.
    7. berikut contoh method yang digunakak untuk membuat data faker di factory class:
        public function definition()
        {
            return [
                'title' => $this->faker->sentence(mt_rand(2, 7)),
                'slug' => $this->faker->unique()->slug(mt_rand(1, 5)),
                'excerpt' => $this->faker->paragraph(),
                'body' => $this->faker->paragraph(mt_rand(10,20)),
                'user_id' => mt_rand(1, 5),
                'category_id' => mt_rand(1, 3)
            ];
        }
    8. Berikut contoh code yang digunakan untuk menjalankan method yang ada di factory yang dituliskan di databaseSeeder.js
        Post::factory(20)->create();
        // artinya membuat data untuk model post sebanyak 20 kali berdasarkan function definition di file postFactory
    9. Post::latest()->get() // digunakan untuk mengambil data dari model post dengan urutan post yang paling terbaru

Episode 11: (n+1 problem)
    1. Kita bisa menggunakan satu view untuk berbagai route yang berbeda. Seperti view posts pada project ini.
    2. n+1 Problem adalah suatu masalah yang terjadi ketika aplikasi kita mengambil data dari database, dimana kita melakulan looping terhadap data kita. Oleh karena itu, kita melakukan pemanggilan ke database secara berulang-ulang.
    3. Kita bisa menggunakan tool clock work untuk mengetahui berapa kali aplikasi kita melakukan pemanggilan quey ke database.
    4. composer require itsgoingd/clockwork // perintah untuk menginstall clockwork
    5. n+1 problem disebut juga lazy loading, jadi saat dibutuhkan saja baru dipanggil.
    6. Untuk menghindari n+1 problem kita bisa menggunakan konsep eager load.
    7. Kita bisa menerapkap eager loop dengan fungsi with(['<namaModel1>','<namaModel2>'])
    8. Contoh eager load:
        Post::with(['author','category'])->latest()->get()
        // Artinya: ambil data dari model post dan juga dari model author dan category, jadi kita hanya melakukan pemanggilan 3 query saja, yaitu select post, select author, dan select category.
    9. Selain eager load ada juga lazy eager load dengan kata kunci load().
    10. Lazy eager load adalah konsep mengambil data dari relasi tabel jika data parent sudah didapatkan. Seperti menampilkan post berdasarkan category, jadi post inilah yang disebut parent.
    11. Contoh penggunaan:
        'posts' => $author->posts->load('category','author')
        // Artinya ambil data posts berdasarkan author, kemudian load juga category dan author berdarkan foreign key yang ada di model posts.

Episode 12: (Redesign UI)
    1. Kita tidak perlu lagi menuliskan fungsi with() di controller. Kita bisa membuat variable protected yang bernama $with.
    2. Contohnya dari no. 1: (Memindahkan eager loading ke model)
        $post->with('category','author')->latest()->get() // di file controller post, sebelum diubah
        diubah ke:
        $with = ['category','author']; // di file model post
        $post->latest()->get() // di file controller post
    3. Kita bisa mengambil postingan pertama dengan $posts[0]
    4. diffForHumans() adalah fungsi yang digunakan untuk merubah datetime format ke string yang mudah dibaca, seperti "2 minutes ago"
        Contoh penggunaan diff:
            $posts[0]->created_at->diffForHumans() // merubah data post berupa field created_at ke string yang mudah dibaca.
    5. skip(param) adalah fungsi yang digunakan untuk mengskip data sebanyak parameter yang diinputkan.
        Contoh:
            @foreach ($posts->skip(1) as $post) // melakukan perulangan tetapi mengskip data sebanyak 1 dari index 0.
    7. SetUp div class saat akan membuat row dan diisi dengan card:
        <div class="container">
            <div class="row">
                <div class="col-md-4">
                    <div class="card">

                    </div>
                </div>
                <div class="col-md-4">
                    <div class="card">

                    </div>
                </div>
                <div class="col-md-4">
                    <div class="card">

                    </div>
                </div>
            </div>
        </div>

Episode 13: (Searching dan Pagination)
    1. Untuk membuat sebuah row posisinya ditengah, kita bisa menambahkan class justify-content-center.
        contoh:
            <div class="row justify-content-center">
                <div class="col-md-6">

                </div>
            </div>
    2. Untuk membuat fitur pencarian kita bisa menuliskan seperti ini pada fungsi index pada model post:
            $posts = Post::latest(); // digunakan untuk mengambil semua data dengan urutan terbaru
            if(request('search')){
                $posts->where('title', 'like', '%' . request('search') . '%'); // jika terdapat request search maka akan mengambil semua data dengan tambahan fungsi where(namaKolom, like, keyword)
            }
            return view('posts', [
                'posts' => $posts->get()
            ]);
    3. Jika query diatas digunakan untuk get data berdasarkan title, kita bisa juga menambahkan fungsi orWhere('body', 'like', '%' . request('search') . '%') agar pencariannya juga bisa berdasarkan field body.
    4. Sebenarnya select where adalah tugas dari model, jadi kita haruda memindahkan hal diatas dari controller ke post model. Dengan mendeklarasikan fungsi yang bernama scopeFilter().
        Contoh:
            public function scopeFilter($query){
                if(request('search')){
                    return $query->where('title', 'like', '%' . request('search') . '%')
                                ->orWhere('body', 'like', '%' . request('search') . '%');
                }
            }
    5. Kita bisa menggunak fungsi schopeFilter tidak hanya untuk search saja, kita juga bisa untuk meng-filter post berdasarkan category dan author. Yaitu dengan cara menambahkan parameter array yang berisi request.
    6. Kita juga bisa mengubah if seperti di function scopeFilter dengan menggunakan fungsi when().
            Contoh:
                $collection->when(true, callBack);
    7. Kita dapat mengganti fungsi isset($filters['search']) dengan  ?? false, jadi jika $filters['search'] itu null akan mengembalikan value false.
    8. Berikut contoh penggunaan fungsi when() di dalam method scopeFilter():
            public function scopeFilter($query, array $filters){
                $query->when($filters['search'] ?? false, function($query, $search){
                   return $query->where('title', 'like', '%' . $search . '%')
                                ->orWhere('body', 'like', '%' . $search . '%');
                });
            }
    9. Kita bisa mengambil url berupa string dengan request()->segment(index)
            Contoh url: localhost/users/malang/1
            request()->segment(1); // users
            request()->segment(2); // malang
            request()->segment(3); // 1
    10. Untuk search post berdasarkan category dan title/body kita dapan menambahkan fungsi berikut pada model post (search dengan relasi tabel):
            $query->when($filters['category'] ?? false, function($query, $category){
                return $query->whereHas('category', function($query) use ($category){
                    return $query->where('slug', $category);
                });
            });
            // artinya ketika variable $filters['category'] ada value nya, maka jalankan fungsi callback yang didalamnya ada fungsi whereHas() yang berfungsi untuk menentukan tabel mana yang akan dicari fieldnya, kemudian menjalankan fungsi callback lagi yang mempunyai parameter $query dan $category, karena $category tidak bisa diakses maka harus menggunakan perintah use ($category), kemudian barulah mereturn $query->where('slug', $category);
    11. Untuk menggunakan fitur pagination kita hanya butuh mengganti fungsi get() ke paginate(jumlah data)
            before:
                "posts" => $post->latest()->filter(request(['search', 'category', 'author']))->get()
            after:
                "posts" => $post->latest()->filter(request(['search', 'category', 'author']))->paginate(7)
    12. Selain itu kita juga harus menambahkan navigasi paginationnya di view dengan memanggil fungsi links(), berikut codenya:
            <div class="d-flex justify-content-end"> // div ini digunakan untuk mengposisikan navigasi ke kanan
                {{ $posts->links() }}
            </div>
    13. Untuk navbar diatas default stylingnya dengan tailwind jadi kita harus konfigurasi dulu jika ingin menggunakan bootstrap, untuk configurasinya kita bisa buka App/Providers/AppServiceProvider.php dan tambahkan code ini di fungsi boot():

            Paginator::useBootstrap();

    Dan jangan lupa import class paginator nya dengan menulis code ini:

            use Illuminate\Pagination\Paginator;

Episode 14 (Membuat view login dan register):
    1. Cara untuk membuat route yang terhubung dengan controller:
        Route::get('/login', [ControllerLogin::class, 'index']); // jadi get adalah methodnya, controller login adalah nama class controllernya, dan index adalah nama fungsi yang ada di dalam class controller yang akan dipanggil.
    2. Untuk cara cepat mengimport class, kita bisa click kanan dan pilih opsi import all classes.
    3. Jika kita ingin menengahkan text yang display inline, kita harus menambahkan display block agar bisa di centerkan, berikut codenya:
        <small class="d-block text-center">TEXT</small>

Episode 15 (User Registration):
    1. Kita bisa menggunakan endpoint yang sama saat menampilkan form register dan memproses data register, tetapi methodnya harus berbeda. Berikut codenya:
        Route::get('/register', [RegisterController::class, 'index']);
        Route::post('/register', [RegisterController::class, 'store']);
    2. Berikut nama-nama function dan fungsinya yang sering orang-orang pakai, sebenarnya nama funtion ini boleh bebas tidak berpengaruh pada kinerja aplikasi.
        - index: biasanya digunakan untuk menampilkan semua data.
        - create: biasanya digunakan untuk menampilkan form yang digunakan input data.
        - store: digunakan untuk insert data dari form ke database.
        - edit: digunakan untuk menampilkan form yang digunakan untuk mengedit data yang ada.
        - update: digunakan untuk update data dari form ke database.
        - destroy: digunakan untuk menghapus data.
    3. Ada fitur laravel yang bertugas untuk mengamankan form dari pembajakan yaitu CSRF(cross-site request forgery), jadi sebenarnya csrf adalah sebuah teknik serangan terhadap website kita, biasanya serangan ini memalsukan request dari site lain dengan url yang sesuai dengan web kita. Oleh karena itu tersedia fitur csrf yang bertugas untuk membuat token untuk mengvalidasi bahwa form tersebut berasal dari web kita (menjaga bahwa request tersebut datangnya dari website kita). Untuk menggunakan itu kita bisa menuliskan @crfs di view form nya. Berikut codenya:

        <form action="/register" method="POST">
            @csrf // kita hanya perlu menambahkan ini di dalam form.
            <input type="email" name="email" />
        </form>

        sebenarnya @csrf dibelakang layar, seperti ini:

         <form action="/register" method="POST">
            <input type="hidden" name="_token" value="{{ csrf_token() }}" /> // sebenarnya @csrf melakukan ini.
            <input type="email" name="email" />
        </form>
    4. Ada dua cara mengambil request:
        a. menggunakan fungsi request():
            public function create(){
                return request->all();
            }
        b. menggunakan model binding:
            public funtion create(Reequest $request){
                return $request->all();
            }
    5. Kita bisa mengvalidasi request agar tidak sembarangan diproses oleh aplikasi, kita bisa mnggunakan fungsi validate() untuk mengvalidasi request, berikut contoh penggunaannya:
        public function create (Request $request){
            $request->validate([
                'name' => 'required|max:255', // kita bisa menggunakan tanda pipe ( | ) untuk menambahkan validasi apa saja yang dibutuhkan.
                'username' => ['required','min:3', 'max:255', 'unique:users'] // kita juga bisa menggunakan array untuk menentukan validasi apa saja.

            ]);
        }
    6. Jika validasi diatas hasilnya false atau tidak sesuai ketentuan kita bisa memberikan warna kotak inputan menjadi merah error di element input dengan bantuan class bootstrap, kita bisa menyisipkan code ini ke class input:
        <input type="text" name="name" class="@error is-invalid @enderror"> // @error('name') is-invalid @enderror inilah yang akan menambahkan class is-invalid jika terjadi error pada field name.
    7. Untuk menampilkan pesan error dari validasi inpuan tersebut kita bisa menggunakan class bootstrap yang bernama invalid-feedback, berikut penggunaannya:
        @error('name')
            <div class="invalid-feedback">
                {{ $message }}
            </div>
        @enderror
    Jadi jika input name tidak sesuai validasi akan menampilkan pesan error berdasarkan validasi.
    8. Jika inputan error maka value semua inputan akan menjadi kosong, agar tidak kosong kita bisa menambakah sebuat attribute di dalam element input, berikut codenya:
        <input type="text" name="name" class="@error is-invalid @enderror" value={{ old('name') }}> // tambahkan value={{ old('name inputnya') }}.
    9. Untuk menambahkan inputan form tersebut ke database kita bisa menyimpan validasi diatas ke dalam variable, kemudian jadikan argument pada fungsi create, berikut untuk codenya:
        $validatedData = $request->validate([
            'name' => 'require|max:255'
        ]);
        User::create($validatedData);
    10. Mass Asshnment adalah sebuah fitur laravel yang bertugas untuk membatasi field mana saja yang boleh diinput ke database dan yang tidak boleh diinput. Untuk membatasi hal tersebut kita bisa menggunakan 2 variable yaitu $fillable dan $guarded, jika fillable digunakan untuk menyimpan field mana saja yang boleh diisi, dan jika guarded berfungsi untuk menyimpan field mana saja yang tidak boleh diisi. Mass assignment ini bertujuan untuk keamanan inputan dan mempersingkan code saat input, jadi kita hanya perlu menuliskan code ini jika ingin insert data: User::create($request->all());, berikut cara penulisan variable mass assignment di model:

        protected $fillable = ['name', 'email', 'password'];
        protected $guarded = ['id']; // kita bisa menuliskan salah satu variable ini di model.

    11. Kita bisa meng-enkripsi data dengan 2 cara yaitu:
        a. $validatedData['password'] = bcrypt($validatedData['password']);
        b. $validatedData['password'] = Hash::make($validatedData['password']); // untuk menggunakan cara ini, jangan lupa untuk mengimport class hash terlebih dahulu, dua cara ini sama-sama menggunakan hash paswwors bcryt.
    12. Kita bisa menggunakan fungsi redirect() untuk berpindah halaman, serta menggunakan fungsi with('alert', 'succes') untuk mengirimkan session, berikut contoh codenya:
        redirect('/login')->with('alert', 'Added account successfully.');
    13. Fungsi with diatas sama dengan code dibawah ini:
        $request->session()->flash('success', 'Registration successfully');
        Oleh karena itu menggunakan fungsi with bisa lebih efektif dan ringkas.
    14. 'password' => [ 'required', Password::min(8)->mixedCase()->letters()->numbers()->symbols()->uncompromised()],
        Code diatas adalah validasi password agar strong, mudah bukan hehe.

Episode 16 (User Login dan Middleware)
    1. Kita bisa menambahkan attribute autofocus pada element input html, agar saat web di load, otomatis cursor mengarah ke input tersebut, contoh:
        <input type="text" name="name" autofocus>
    2. Untuk membuat fitur login kita bisa membuat fungsi dalam controller login yang bernama authenticate(), jangan lupa untuk membuat route dengan method post, berikut code untuk fungsi tersebut:
        public function authenticate(Request $request){
            $credentials = $request->validate([
                'email' => 'rquired|email:dns',
                'password' => 'required'
            ]); // digunakan untuk validasi input form
            if(Auth::attemp($credentials)){ // mengcek apakah email dan password ini terdaftar
                $request->session()->regenerate();
                return redirect()->intended('/dashboard'); // jika true akan redirect ke halaman /dashboard, untuk menggunakan intended() karena nantinya akan ada validasi middleware.
            }else{
                return back()->with('loginError','Login failed!'); // jika false akan return back ke halaman login dan mengirimkan session login failed
            }
        }
    3. Middleware menyediakan sebuah mekanisme yang memudahkan kita untuk melakukan inpeksi dan filtering http request. Contohnya, laravel sudah menyediakan sebuah middleware yang melakukan verifikasi apakah seorang user dari aplikasi kita sudah ter-otentikasi atau belum. Jika belum ter-otentikasi, maka middleware tadi akan melakukan redirect ke halaman login. Tapi jika sudah ter-otentikasi maka middleware akan mengijinkan kita untuk masuk kedalam aplikasinya.
    4. Middleware adalah sebuah software yang berjalan di tengah sesuatu.
    5. Berikut contoh middleware laravel default:
        a. guest artinya belum login
        b. auth artinya sudah login/sudah ter-otentikasi.
    6. Berikut cara menuliskan middleware di route:
        Route::get('/login', [LoginController::class, 'index'])->middleware('guest'); // artinya hanya guest yang bisa mengakses route ini.
    7. Cara mengatur default route/route yang akan dibuka ditolak oleh middleware,
        a. Buka folder App/Providers
        b. Buka file RouteServiceProvider.php
        c. ubah variable ini public const HOME = '/home'; menjadi route yang diinginkan.
    8. Di blade sudah tersedia directive path yang digunakan untuk memunculkan element jika user sudah login atau belum login, yaitu:
        @auth {{  }} @endauth
        @guest {{  }} @endguest

        dua hal tersebut bisa ditambahkan else, jadi seperti ini

        @auth
            {{  }}
        @else
            {{  }}
        @endauth

    9.  Kita bisa mengambil data user setelah user login dengan cara ini, misalnya mengambil nama:
        {{ auth()->user()->name }}
    10. Berikut fungsi logout() yang berfungsi untuk logout dan untuk invalidate session:
        public function logout(Request $request){
            Auth::logout();
            $request->session()->invalidate();
            $request->session()->regenerateToken();
            return redirect('/');
        }
    11. Kita juga bisa memberi nama route dengan fungsi name('namaroute'), berikut contoh code nya:
        Route::get('/login', [LoginController::class, 'index'])->name('login')->middleware('guest');
    12. Jika kita ingin mengganti default tabel untuk auth kita bisa menggantinya di Config/Auth.php, default table auth adalah tabel users.

Episode 17 (Dashboard UI):
    1. Selain menggunakan bootstrap icon kita juga bisa gunakan feather icon. Berikut cara menampilkan iconnya:
        <span data-feather="log-out(slug-icon)" class="align-text-bottom"></span>
    2. Kita bisa menggunakan fitur laravel yang bernama resource controller, jadi resource controller digunakan untuk mengelola data CRUD dan akan dibuatkan route CRUD secara otomatis.
    3. Cara membuat resource controller yaitu dengan menuliskan command ini:
        php artisan make:controller PostController --resource
    4. Untuk route resources controller, kita tidak perlu membuat satu-satu route crudnya, kita dapat menuliskannya seperti ini:
        Route::resource('posts', PostController::class);
    5. Kita juga bisa saat membuat resource controller memberi imbuhan --model=Post, untuk memberitahu sistem bahwa controller ini terhubung dengan model Post. Berikut commandnya:
        php artisan make:controller PostController --resource --model=Post
    6. Berikut cara mengambil data berdasarkan user yang sedang login:
        return Post::where('user_id', auth()->user()->id)->get();
    7. Validasi email:dns, tidak support untuk tes@example.org karena dns tersebut tidak terdaftar.
    8. Kita bisa menggunakan variable $loop->iteration untuk memberi nomer pada table.
    9. Untuk route resource untuk melakukan model binding defaultnya berdasarkan id, untuk merubah hal tersebut kita bisa tambahkan fuction ini di dalam class model nya:
        public function getRouteKeyName(){
            return 'slug'; // jika ingin menggunakan slug untuk pencariannya (where).
        }
    10. Berikut daftar route resource yang diadakan secara otomatis:
        code routenya: Route::resource('/posts', PostController::class);
                         endpoint           | method | fungsi  | route name
        daftar route: a. /posts             | GET    | index   | posts.index   // untuk menampilkn data
                      b. /posts/create      | GET    | create  | create.index  // untuk menampikan form insert data
                      c. /posts             | POST   | store   | store.index   // untuk insert data dari form
                      d. /posts/{post}      | GET    | show    | show.index    // untuk menampilkan satu data
                      e. /posts/{post}/edit | GET    | edit    | edit.index    // untuk menampikan form edit data
                      f. /posts/{post}      | PUT    | update  | update.index  // untuk update data dari form ke database
                      g. /posts/{post}      | DELETE | destroy | destroy.index // untuk menghapus data dari database

Episode 18 (Create Form Post):
    1. Kita bisa menggunakan fitur eloquent sluggable untuk membuat slug otomatis, berikut cara install nya:
        composer require cviebrock/eloquent-sluggable
    2. Cara menggunakan tools sluggable untuk crete post:
        1). Masuk file model yang akan menggunakan fitur ini, contohnya model post.
        2). Import pakage sluggable, dengan mengtikkan code ini:
            use Cviebrock\EloquentSluggable\Sluggable
        3). Ketik code ini untuk mengguanakan sluggable di dalam class:
            use Sluggable;
        4). Buat funtion dalam class model seperti ini:
            public function sluggable(): array{
                return[
                    'slug' => [
                        'source' => 'title' // artinya, kita akan membuat slug berdasarkan field title
                    ]
                ];
            }
        5). Buat fungsi yang bernama createSlug() di model post seperti ini:
            public function createSlug(Request $request)
            {
                $slug = SlugService::createSlug(Post::class, 'slug', $request->title);
                return response()->json(['slug' => $slug]);
            }
        jangan lupa untuk inport class SlugService dengan ini:
            use \Cviebrock\EloquentSluggable\Services\SlugService;
        fungsi diatas berfungsi untuk menerima request dari url berupa title dam memprosesnya menjadi slug, kemudian dikembalikan berupa response json.
        6). Ketikkan code javascript ini di dalam file yang ada form create postnya: (pastikan name inputnya title dan slug)
            <script>
                const title = document.querySelector('#title');
                const slug = document.querySelector('#slug');

                title.addEventListener('change', function(){
                    fetch('/dashboard/posts/createSlug?title=' + title.value)
                        .then(response => response.json())
                        .then(data => slug.value = data.slug)
                });
            </script>
        code itu digunakan untuk menangkap inputan berupa title dan mengerimkannya ke fungsi createSlug di controller post, dan mengambil response berupa slug, dan menyisipkannya ke dalam form input utuk slug.
    3. Untuk form input body postingan kita bisa menggunakan beberapa text editor seperti trix editor, ckeditor, dll.
    4. Untuk project ini kita menggunakan trix editor, berikut cara pakainya:
        a. buka github trix editor berikut link nya: https://github.com/basecamp/trix
        b. download repositori itu.
        c. copy file trix.css dan trix.js ke dalam folder public/css dan public/js.
        d. import file css dan js di dalam file main.blade.php berikut codenya:
            {{-- Style for trix editor --}}
            <link rel="stylesheet" type="text/css" href="/css/trix.css">
            <script type="text/javascript" src="/js/trix.js"></script>
        e. tuliskan code html ini beserta inputannya, untuk menampilkan trix editornya:
            <label for="body" class="form-label">Body</label>
            <input id="body" type="hidden" name="body">
            <trix-editor input="body"></trix-editor> // untuk attribute input di tag trix dan attribute id di tag input harus sama.
        f. jika default trix terdapat tools untuk mengupload file gambar, untuk menghilangkannya kita bisa menggunakan code css ini di tag head:
            <style>
                trix-toolbar [data-trix-button-group="file-tools"] {
                    display: none;
                }
            </style>
        kemudian tambahkan script javascrit ini:
            document.addEventListener('trix-file-accept', function(e){
                e.preventDefault();
            })

Episode 19 (Validation form post and insert form):
    1. Jika menggunakan trix editor, kita bisa menyisipkan valuenya di bagian hidden input saat ada validasi lain yang salah berikut codenya:
        <label for="body" class="form-label">Body</label>
        <input id="body" type="hidden" name="body" value="{{ old('body') }}">
        <trix-editor input="body"></trix-editor>
        @error('body')
            <p class="text-danger">{{ $message }}</p>
        @enderror
    2. Kita bisa menggunagan fungsi Str::limit() untuk membuat excerpt secara ototatis berdasarkan body, berikut codenya:
        $validatedData['excerpt'] = Str::limit($request->body, 100, '...'); // Str::limit('string', 'jumlah limit', 'imbuhan apa untuk di paling belakang, default: '...');
    jika string tersebut mengandung tag html kita bisa gunakan fungsi strip_tags() untuk menghilangkan tag nya.

Episode 20 (Update dan Delete Post):
    1. Dikarenakan pada form html biasa hanya support 2 method form yaitu get dan posts, jika kita ingin menggunakan method delete kita bisa gunakan form seperti ini:
        <form action="/dashboard/posts/{{ $post->slug }}" method="post">
            @method('delete') // tambahan ini
            @csrf
            <button type="submit" class="badge bg-danger"><span data-feather="x-circle"></span></button>
        </form>
    2. Form diatas akan berbentuk display block, dan karena itu button maka akan ada bordernya, berikut untuk mengembalikan tampilannya:
        <form action="/dashboard/posts/{{ $post->slug }}" method="post" class="d-inline">
            @method('delete')
            @csrf
            <button type="submit" class="badge bg-danger border-0"><span data-feather="x-circle"></span></button>
        </form>
    3. Berikut fungsi destroy pada controller post untuk menghapus postingan:
        public function destroy(Post $post)
        {
            Post::destroy($post->id);
            return redirect('/dashboard/posts')->with('success', 'Post has been deleted!');
        }
    4. Berikut cara membuat form update:
        a. Code untuk fungsi edit di controller post:
            public function edit(Post $post)
            {
                return view('dashboard.posts.edit', [
                    'title' => 'Edit Post',
                    'post' => $post,                 // data ini yang akan diedit di form edit
                    'categories' => Category::all()  // untuk select form
                ]);
            }
        b. Berikut form untuk edit data:
            <form action="/dashboard/posts/{{ $post->slug }}" method="POST" class="mb-5">
                @method('put')
                @csrf
                <div class="mb-3">
                    <label for="title" class="form-label">Title</label>
                    <input type="text" class="form-control @error('title') is-invalid @enderror" id="title" name="title"
                        placeholder="Title" required autofocus value="{{ old('title', $post->title) }}">
                    @error('title')
                        <div class="invalid-feedback">
                            {{ $message }}
                        </div>
                    @enderror
                </div>
                <div class="mb-3">
                    <label for="slug" class="form-label">Slug <small>(Read only)</small></label>
                    <input type="text" class="form-control @error('slug') is-invalid @enderror" id="slug" name="slug"
                        readonly placeholder="Auto generated by title" required value="{{ old('slug', $post->slug) }}">
                    @error('slug')
                        <div class="invalid-feedback">
                            {{ $message }}
                        </div>
                    @enderror
                </div>
                <div class="mb-3">
                    <label for="category" class="form-label">Category</label>
                    <select class="form-select @error('category_id') is-invalid @enderror" name="category_id" required>
                        <option value="">Select category</option>
                        @foreach ($categories as $category)
                            @if (old('category_id', $post->category_id) == $category->id)
                                <option value="{{ $category->id }}" selected>{{ $category->name }}</option>
                            @else
                                <option value="{{ $category->id }}">{{ $category->name }}</option>
                            @endif
                        @endforeach
                    </select>
                    @error('category_id')
                        <div class="invalid-feedback">
                            {{ $message }}
                        </div>
                    @enderror
                </div>
                <div class="mb-3">
                    <label for="body" class="form-label">Body</label>
                    <input id="body" type="hidden" name="body" value="{{ old('body', $post->body) }}">
                    <trix-editor input="body"></trix-editor>
                    @error('body')
                        <p class="text-danger">{{ $message }}</p>
                    @enderror
                </div>
                <button type="submit" class="btn btn-primary">Create</button>
                <a href="/dashboard/posts" class="btn btn-danger">Cancel</a>
            </form>
        c. Dari code diatas, cara untuk menampilkan data yg akan diupdate dan data old yaitu begini:
            value="{{ old('title', $post->title) }}" 
        artinya jika value old tidak ada maka tampilkan $post->title, dan jika value old ada ya tampilkan old('title').
        d. Ingat untuk url ini:
            edit: /posts/{{ $post->slug }}/edit // untuk menampilkan form, method = get
            update: /posts/{{ $post->slug }} // untuk proses update, method = put
        e. Berikut untuk fungsi update():
            public function update(Request $request, Post $post)
            {
                $rules = [
                    'title' => 'required|max:255',
                    'category_id' => 'required',
                    'body' => 'required'
                ];

                if($request->slug != $post->slug){
                    $rules['slug'] = 'required|unique:posts';
                }else{
                    $rules['slug'] = 'required';
                }

                $validatedData = $request->validate($rules);

                $validatedData['user_id'] = auth()->user()->id;
                $validatedData['excerpt'] = Str::limit(strip_tags($request->body), 200);

                Post::where('id', $post->id)->update($validatedData);
                return redirect('/dashboard/posts')->with('success', 'Post has been edited!');
            }
        f. Berikut alur dari fungsi update:
            1. Deklaradi rules untuk validasi request.
            2. Jika slug tidak diubah maka validasinya akan required saja, karena jika ada validasi unique maka tidak lolos validasi.
            3. Jika slug diubah maka validasi slugnya required dan unique:posts.
            4. Kemudian validasi request berdasarkan rules yg sudah dideklarasikan dan disimpan di variable $validatedData.
            5. Kemudian simpan user_id ke variable $validatedData.
            6. Kemudian simpan excerpt yg sudah di limit ke variable $validatedData.
            7. Lalu barulah menjalankan fungsi update dengan parameter $validatedData, berdasarkan id post. (id post diambil berdasarkan slug post)
            8. Terakhir redirect ke halaman daftar post, dan dengan mengembalikan session berupa alert.
    5. PENTING: Untuk membatasi user agar hanya bisa mengelola postingannya sendiri kita bisa sisipkan script ini:
        if($post->author->id !== auth()->user()->id) {
            abort(403);
        }
    jadi fungsi abort(403), menampilkan view forbidden dengan status 403. Kita bisa tambahkan ini ke dalam fungsi show, edit, dan store.

Episode 21 (Upload Image):
    1. Jika kita ingin input type file, kita harus menambahkan attribute pada tag form yaitu enctype="multipart/form-data", berikut contohnya:
        <form action="/dashboard/posts" method="POST" class="mb-5" enctype="multipart/form-data">
        </form>
    2. Cara upload file, berikut cara file dengan fungsi store(), yg masih belum ada validasi file sama sekali:
        return $request()->file('image')->store('post-images');
    artinya tangkap request berupa file yg nama imputannya IMAGE, kemudian simpan ke dalam folder /storage/app/post-image dengan nama yg random.
    3. Unutk mengatur upload file di laravel sudah disediakan tool yang bernama FLYSYSTEM. keren bukan ?
    4. Untuk mengatur default penyimpanan file kita bisa konfigurasi di file config/filesystems.php, disana tertulis bahwa default penyimpanan ada di folder storage/app/
    5. Dikarenakan jika file disimpan di storage/app tidak bisa diakses secara public maka kita harus merubah default filesystem yg sebelumnya local menjadi public, kita bisa merubahnya di environment variable yg variable nya bernama FILESYSTEM_DRIVER.
    6. Kita juga perlu konfigurasi lagi agar folder storage/public bisa diakses, proses ini dinamakan symbolic link, berikut caranya:
        -ketikkan command berikut:
            php artisan storage:link
        ini digunakan untuk mengkoneksikan antara folder storage/public dan folder public application
    7. Berikut cara untuk mengvalidasi image, hampir sama seperti inputan yang lain. Berikut codenya:
        $validatedData = $request->validate([
            'title' => 'required|max:255',
            'slug' => 'required|unique:posts',
            'image' => 'image|file|max:1024',  // ini unutk validasi image
            'category_id' => 'required',
            'body' => 'required'
        ]);
        if($request->file('image')){ // jika image itu 
            $validatedData['image'] = $request->file('image')->store('post-images'); 
        }
    8. Untuk input image tidak required jadi jika user tidak menginputkan image, image yang ditampilkan diambil dari unplash, berikut untuk menampilkan image di halaman show:
        @if ($post->image) // jika fiel image ada atau tidak null.
            <img src="{{ asset('storage/' . $post->image) }}" // digunakan untuk mengambil gambahr dari folder public/storage/post-image
                alt="{{ $post->category->name }}" class="img-fluid mt-3">
        @else    
            <img src="https://source.unsplash.com/random/1200x400?{{ $post->category->name }}"
                alt="{{ $post->category->name }}" class="img-fluid mt-3">
        @endif

Episode 22 (Membuat fitur preview, update, dan delete image):
    1. Kita bisa tambahkan class pada tag img yaitu img-fluid agar gambar kita bisa responsif.
    2. 
    
    
